# P5-09e Verification Report: Notification Ledger & Retry Governance

## 1. Summary
This document verifies the implementation of the Notification Ledger UI and the secure Retry Governance mechanism. This system allows tenant admins to view notification history and retry failed/blocked messages while maintaining strict tenant isolation and audit trails.

## 2. Ledger UI
- **Controller:** `App\Controllers\NotificationLedger`
- **Route:** `GET /notifications/ledger`
- **Scope:** Tenant-scoped (`where('clinic_id', session('active_clinic_id'))`).
- **Features:**
  - Filtering by Status (sent, failed, blocked, pending) and Channel.
  - Masking of sensitive recipient addresses in the view.
  - Action buttons (Retry) available only for actionable statuses.

## 3. Retry Governance (Option B)
- **Mechanism:** "Retry" does not mutate the original row. It creates a **new** ledger entry linked via `parent_notification_id`.
- **Logic:** `NotificationService::retryNotification()`
  - Loads original row.
  - Enforces `clinic_id` match (Anti-IDOR).
  - Copies recipient and payload.
  - Calls `enqueue()` to re-validate registry/recipient rules.
  - Sets `status` to pending (or blocked if rules fail).

## 4. Verification Tests (UI + Route)
**Ledger UI:**
1. Clinic A loads `/notifications/ledger` and sees only Clinic A rows.
2. Clinic B does not see Clinic A rows.

**Retry Governance:**
1. Clinic A retries a failed row via POST `/notifications/ledger/retry/{id}`.
   - New row created with `parent_notification_id` = original.
   - Original row remains unchanged.
2. Clinic B retry against Clinic A row returns 403/404 (Fail-Closed).
3. Superadmin (global_mode) can retry any clinic; tenant admins are limited to their clinic.

**Status Handling:** New rows enter the standard lifecycle (Pending/Blocked).

## 5. Guardrails Check
**Command:** `bash scripts/ci/saas_guardrails.sh`
**Result:** Passed.
- DOM Sinks: 0
- Auth Bypasses: 0
- Raw Tenant Queries: 8 (Baseline maintained)
